import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import uniform, norm

# z1
# n = 17
# b = 6
# d = n+b
#
# Pnn = round(n/d*(n-1)/(d-1), 2)
# Pbb = round(b/d*(b-1)/(d-1), 2)
# Pnb = round(1 - Pbb - Pnn, 2)
#
# P = {20: Pnn, -10: Pnb, -40: Pbb}
# mean = sum([key*P[key] for key in P.keys()])
# print(mean)

# z2
# d = 1200
# d_0_3 = 70
# d_3_4 = 50

# Частота отказов по статистическим данным об отказах определяется выражением
#                                   f(t)  = dn(t)/(N*dt)
# dn(t) - число отказавших изделий на участке времени (t, t + Δt)
# dt - интервал врeмени
# N - число изделий, поставленных на испытания

# f_3_4 = d_3_4/(d*1000)

# Интенсивность отказов по статистическим данным об отказах определяется формулой
#                                  l(t)  =  dn(t)/(dt*n(t))
# n(t)- число изделий, не отказавших к моменту времени t
# dn(t) - число отказавших изделий на участке времени (t, t + Δt)
# dt - интервал врeмени

# l_3_4 = d_3_4/(1000*(d-d_0_3))
# print(f_3_4, l_3_4)

# z3
# e = 15
# t0 = 258
# t1 = 1233
#
# dt = t1-t0

# Наработкой на отказ называется среднее значение времени между соседними отказами.
#                                   t(ср) = (t / n), где
# t - время наблюдения
# n - число отказов

# tcp = dt/e

# z4
# t = 100
# p = [0.996, 0.9998, 0.9996, 0.999, 0.9998]


# По условию задачи отказы приборов независимы, поэтому вероятность безотказной
# работы системы равна произведению вероятностей безотказной работы приборов.
# Тогда для случая высоконадежных систем имеем:
#
#                                 Pc(t) = 1 - sum(qi(t))

# q = 1-sum([1-pi for pi in p])

# Так как вероятность безотказной работы близка к единице, то интенсивность
# отказов можно вычислить с помощью выражения:
#                                  lambda  =  1-Pc(t)/dt

# lambda_c = (1 - q) / t

# Тогда частота отказов будет получена по формуле:
#                                 ac(t) = lambda * (1 - lambda * dt)
# ac = lambda_c * (1 - lambda_c * t)
#
# print(ac)

# z5
m = 250
b = 18
r = 18
g = 1

c = r+g+b
pbg = (b+g)/c
pr = r/c
w = {-m:pbg, 250:pr}
m = sum([key*w[key] for key in w.keys()])
print(m)